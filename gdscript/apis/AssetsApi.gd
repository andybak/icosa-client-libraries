extends ApiBee
class_name AssetsApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AssetsApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AssetsApi"


# Operation icosaApiAssetsDeleteAsset → DELETE /v1/assets/{asset}
# Delete Asset
func icosa_api_assets_delete_asset(
	# asset: String   Eg: asset_example
	asset: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/v1/assets/{asset}".replace("{" + "asset" + "}", _bzz_urlize_path_param(asset))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func icosa_api_assets_delete_asset_threaded(
	# asset: String   Eg: asset_example
	asset: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "icosa_api_assets_delete_asset")
	bzz_callable.bind(
		asset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation icosaApiAssetsGetAsset → GET /v1/assets/{asset}
# Get Asset
func icosa_api_assets_get_asset(
	# asset: String   Eg: asset_example
	asset: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/v1/assets/{asset}".replace("{" + "asset" + "}", _bzz_urlize_path_param(asset))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetSchemaOut.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func icosa_api_assets_get_asset_threaded(
	# asset: String   Eg: asset_example
	asset: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "icosa_api_assets_get_asset")
	bzz_callable.bind(
		asset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation icosaApiAssetsGetAssets → GET /v1/assets
# Get Assets
func icosa_api_assets_get_assets(
	# category: String   Eg: category_example
	category = null,
	# curated: bool = false   Eg: true
	curated = false,
	# format: Array
	format = null,
	# keywords: String   Eg: keywords_example
	keywords = null,
	# name: String   Eg: name_example
	name = null,
	# description: String   Eg: description_example
	description = null,
	# tag: Array
	tag = null,
	# orderBy: String   Eg: orderBy_example
	orderBy = null,
	# orderBy2: String   Eg: orderBy_example
	orderBy2 = null,
	# maxComplexity: Complexity
	maxComplexity = null,
	# triangleCountMin: int   Eg: 56
	triangleCountMin = null,
	# triangleCountMax: int   Eg: 56
	triangleCountMax = null,
	# authorName: String   Eg: authorName_example
	authorName = null,
	# authorName2: String   Eg: authorName_example
	authorName2 = null,
	# license: String   Eg: license_example
	license = null,
	# pageToken: String   Eg: pageToken_example
	pageToken = null,
	# pageToken2: String   Eg: pageToken_example
	pageToken2 = null,
	# pageSize: String   Eg: pageSize_example
	pageSize = null,
	# pageSize2: String   Eg: pageSize_example
	pageSize2 = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/v1/assets"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["category"] = category
	bzz_query["curated"] = curated
	bzz_query["format"] = format
	bzz_query["keywords"] = keywords
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["tag"] = tag
	bzz_query["orderBy"] = orderBy
	bzz_query["order_by"] = orderBy2
	bzz_query["maxComplexity"] = maxComplexity
	bzz_query["triangleCountMin"] = triangleCountMin
	bzz_query["triangleCountMax"] = triangleCountMax
	bzz_query["authorName"] = authorName
	bzz_query["author_name"] = authorName2
	bzz_query["license"] = license
	bzz_query["pageToken"] = pageToken
	bzz_query["page_token"] = pageToken2
	bzz_query["pageSize"] = pageSize
	bzz_query["page_size"] = pageSize2

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PagedAssetSchemaOut.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func icosa_api_assets_get_assets_threaded(
	# category: String   Eg: category_example
	category = null,
	# curated: bool = false   Eg: true
	curated = false,
	# format: Array
	format = null,
	# keywords: String   Eg: keywords_example
	keywords = null,
	# name: String   Eg: name_example
	name = null,
	# description: String   Eg: description_example
	description = null,
	# tag: Array
	tag = null,
	# orderBy: String   Eg: orderBy_example
	orderBy = null,
	# orderBy2: String   Eg: orderBy_example
	orderBy2 = null,
	# maxComplexity: Complexity
	maxComplexity = null,
	# triangleCountMin: int   Eg: 56
	triangleCountMin = null,
	# triangleCountMax: int   Eg: 56
	triangleCountMax = null,
	# authorName: String   Eg: authorName_example
	authorName = null,
	# authorName2: String   Eg: authorName_example
	authorName2 = null,
	# license: String   Eg: license_example
	license = null,
	# pageToken: String   Eg: pageToken_example
	pageToken = null,
	# pageToken2: String   Eg: pageToken_example
	pageToken2 = null,
	# pageSize: String   Eg: pageSize_example
	pageSize = null,
	# pageSize2: String   Eg: pageSize_example
	pageSize2 = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "icosa_api_assets_get_assets")
	bzz_callable.bind(
		category,
		curated,
		format,
		keywords,
		name,
		description,
		tag,
		orderBy,
		orderBy2,
		maxComplexity,
		triangleCountMin,
		triangleCountMax,
		authorName,
		authorName2,
		license,
		pageToken,
		pageToken2,
		pageSize,
		pageSize2,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation icosaApiAssetsGetUserAsset → GET /v1/assets/{userurl}/{asseturl}
# Get User Asset
func icosa_api_assets_get_user_asset(
	# userurl: String   Eg: userurl_example
	userurl: String,
	# asseturl: String   Eg: asseturl_example
	asseturl: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/v1/assets/{userurl}/{asseturl}".replace("{" + "userurl" + "}", _bzz_urlize_path_param(userurl)).replace("{" + "asseturl" + "}", _bzz_urlize_path_param(asseturl))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetSchemaOut.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func icosa_api_assets_get_user_asset_threaded(
	# userurl: String   Eg: userurl_example
	userurl: String,
	# asseturl: String   Eg: asseturl_example
	asseturl: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "icosa_api_assets_get_user_asset")
	bzz_callable.bind(
		userurl,
		asseturl,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation icosaApiAssetsUnpublishAsset → PATCH /v1/assets/{asset}/unpublish
# Unpublish Asset
func icosa_api_assets_unpublish_asset(
	# asset: int   Eg: 56
	asset: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("PATCH")

	# Compute the URL path to the API resource
	var bzz_path := "/v1/assets/{asset}/unpublish".replace("{" + "asset" + "}", _bzz_urlize_path_param(asset))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetSchemaOut.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func icosa_api_assets_unpublish_asset_threaded(
	# asset: int   Eg: 56
	asset: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "icosa_api_assets_unpublish_asset")
	bzz_callable.bind(
		asset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


